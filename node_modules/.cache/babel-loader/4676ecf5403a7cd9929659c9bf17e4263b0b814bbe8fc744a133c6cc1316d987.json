{"ast":null,"code":"import _objectSpread from \"C:/Users/oreor/Desktop/website/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/oreor/Desktop/website/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"duration\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"keyframes\", \"autoplay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\", \"type\"];\nimport { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nvar types = {\n  decay: decay,\n  keyframes: keyframes,\n  tween: keyframes,\n  spring: spring\n};\nfunction loopElapsed(elapsed, duration) {\n  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var isForwardPlayback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nvar framesync = function framesync(update) {\n  var passTimestamp = function passTimestamp(_ref) {\n    var delta = _ref.delta;\n    return update(delta);\n  };\n  return {\n    start: function start() {\n      return sync.update(passTimestamp, true);\n    },\n    stop: function stop() {\n      return cancelSync.update(passTimestamp);\n    }\n  };\n};\nfunction animate(_ref2) {\n  var duration = _ref2.duration,\n    _ref2$driver = _ref2.driver,\n    driver = _ref2$driver === void 0 ? framesync : _ref2$driver,\n    _ref2$elapsed = _ref2.elapsed,\n    elapsed = _ref2$elapsed === void 0 ? 0 : _ref2$elapsed,\n    _ref2$repeat = _ref2.repeat,\n    repeatMax = _ref2$repeat === void 0 ? 0 : _ref2$repeat,\n    _ref2$repeatType = _ref2.repeatType,\n    repeatType = _ref2$repeatType === void 0 ? \"loop\" : _ref2$repeatType,\n    _ref2$repeatDelay = _ref2.repeatDelay,\n    repeatDelay = _ref2$repeatDelay === void 0 ? 0 : _ref2$repeatDelay,\n    keyframes$1 = _ref2.keyframes,\n    _ref2$autoplay = _ref2.autoplay,\n    autoplay = _ref2$autoplay === void 0 ? true : _ref2$autoplay,\n    onPlay = _ref2.onPlay,\n    onStop = _ref2.onStop,\n    onComplete = _ref2.onComplete,\n    onRepeat = _ref2.onRepeat,\n    onUpdate = _ref2.onUpdate,\n    _ref2$type = _ref2.type,\n    type = _ref2$type === void 0 ? \"keyframes\" : _ref2$type,\n    options = _objectWithoutProperties(_ref2, _excluded);\n  var _a, _b;\n  var initialElapsed = elapsed;\n  var driverControls;\n  var repeatCount = 0;\n  var computedDuration = duration;\n  var isComplete = false;\n  var isForwardPlayback = true;\n  var interpolateFromNumber;\n  var animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n  var origin = keyframes$1[0];\n  var target = keyframes$1[keyframes$1.length - 1];\n  var state = {\n    done: false,\n    value: origin\n  };\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n    interpolateFromNumber = interpolate([0, 100], [origin, target], {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  var animation = animator(_objectSpread(_objectSpread({}, options), {}, {\n    duration: duration,\n    keyframes: keyframes$1\n  }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls && driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      state = animation.next(Math.max(0, elapsed));\n      if (interpolateFromNumber) state.value = interpolateFromNumber(state.value);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate && onUpdate(state.value);\n    if (isComplete) {\n      if (repeatCount === 0) {\n        computedDuration = computedDuration !== undefined ? computedDuration : elapsed;\n      }\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay && onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: function stop() {\n      onStop && onStop();\n      driverControls && driverControls.stop();\n    },\n    /**\n     * Set the current time of the animation. This is purposefully\n     * mirroring the WAAPI animation API to make them interchanagable.\n     * Going forward this file should be ported more towards\n     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n     * Which behaviourally adheres to WAAPI as far as possible.\n     *\n     * WARNING: This is not safe to use for most animations. We currently\n     * only use it for handoff from WAAPI within Framer.\n     *\n     * This animation function consumes time every frame rather than being sampled for time.\n     * So the sample() method performs some headless frames to ensure\n     * repeats are handled correctly. Ideally in the future we will replace\n     * that method with this, once repeat calculations are pure.\n     */\n    set currentTime(t) {\n      elapsed = initialElapsed;\n      update(t);\n    },\n    /**\n     * animate() can't yet be sampled for time, instead it\n     * consumes time. So to sample it we have to run a low\n     * temporal-resolution version.\n     */\n    sample: function sample(t) {\n      elapsed = initialElapsed;\n      var sampleResolution = duration && typeof duration === \"number\" ? Math.max(duration * 0.5, 50) : 50;\n      var sampleElapsed = 0;\n      update(0);\n      while (sampleElapsed <= t) {\n        var remaining = t - sampleElapsed;\n        update(Math.min(remaining, sampleResolution));\n        sampleElapsed += sampleResolution;\n      }\n      return state;\n    }\n  };\n}\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":{"version":3,"names":["keyframes","spring","decay","sync","cancelSync","interpolate","types","tween","loopElapsed","elapsed","duration","delay","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","delta","start","stop","animate","driver","repeat","repeatMax","repeatType","repeatDelay","keyframes$1","autoplay","onPlay","onStop","onComplete","onRepeat","onUpdate","type","options","_a","_b","initialElapsed","driverControls","repeatCount","computedDuration","isComplete","interpolateFromNumber","animator","length","origin","target","state","done","value","needsInterpolation","call","clamp","animation","flipTarget","complete","next","Math","max","undefined","play","currentTime","t","sample","sampleResolution","sampleElapsed","remaining","min"],"sources":["C:/Users/oreor/Desktop/website/node_modules/framer-motion/dist/es/animation/legacy-popmotion/index.mjs"],"sourcesContent":["import { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\n\nconst types = {\n    decay,\n    keyframes: keyframes,\n    tween: keyframes,\n    spring,\n};\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration = 0, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, keyframes: keyframes$1, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type = \"keyframes\", ...options }) {\n    var _a, _b;\n    const initialElapsed = elapsed;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = duration;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n    const origin = keyframes$1[0];\n    const target = keyframes$1[keyframes$1.length - 1];\n    let state = { done: false, value: origin };\n    if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n        interpolateFromNumber = interpolate([0, 100], [origin, target], {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const animation = animator({\n        ...options,\n        duration,\n        keyframes: keyframes$1,\n    });\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls && driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            state = animation.next(Math.max(0, elapsed));\n            if (interpolateFromNumber)\n                state.value = interpolateFromNumber(state.value);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate && onUpdate(state.value);\n        if (isComplete) {\n            if (repeatCount === 0) {\n                computedDuration =\n                    computedDuration !== undefined ? computedDuration : elapsed;\n            }\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay && onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop && onStop();\n            driverControls && driverControls.stop();\n        },\n        /**\n         * Set the current time of the animation. This is purposefully\n         * mirroring the WAAPI animation API to make them interchanagable.\n         * Going forward this file should be ported more towards\n         * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n         * Which behaviourally adheres to WAAPI as far as possible.\n         *\n         * WARNING: This is not safe to use for most animations. We currently\n         * only use it for handoff from WAAPI within Framer.\n         *\n         * This animation function consumes time every frame rather than being sampled for time.\n         * So the sample() method performs some headless frames to ensure\n         * repeats are handled correctly. Ideally in the future we will replace\n         * that method with this, once repeat calculations are pure.\n         */\n        set currentTime(t) {\n            elapsed = initialElapsed;\n            update(t);\n        },\n        /**\n         * animate() can't yet be sampled for time, instead it\n         * consumes time. So to sample it we have to run a low\n         * temporal-resolution version.\n         */\n        sample: (t) => {\n            elapsed = initialElapsed;\n            const sampleResolution = duration && typeof duration === \"number\"\n                ? Math.max(duration * 0.5, 50)\n                : 50;\n            let sampleElapsed = 0;\n            update(0);\n            while (sampleElapsed <= t) {\n                const remaining = t - sampleElapsed;\n                update(Math.min(remaining, sampleResolution));\n                sampleElapsed += sampleResolution;\n            }\n            return state;\n        },\n    };\n}\n\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}